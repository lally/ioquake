* Runtime Notes
  - SDL will _FAIL_ unless you unset LANG.
  - You can run this in *Xephyr*!!
    pfexec Xephyr :1.0 &
    xauth extract - $DISPLAY | DISPLAY=:1.0 xauth merge -
    DISPLAY=:1.0 ./ioquake3.i386

  - This works  *RELIABLY*
    - You may have to run ioquake a few times to make it go all the
      way through.
    - See build/run.sh !

* Source Code Notes
** Key Routines
   
   | Name            | Location           | Purpose                                                       |
   |-----------------+--------------------+---------------------------------------------------------------|
   | main            | sys/sys_main.c     | main() of program, both client and server.                    |
   | SV_Frame        | server/sv_main.c   | Primary simulation loop                                       |
   | SV_BotFrame     | server/sv_bot.c    | Invoke Bot AI                                                 |
   | BotAIStartFrame | game/g_main.c      | Invokes (vm) call to SV_ClientThink, after maintaining        |
   |                 |                    | internal bot-related data structures.  Seems relevant         |
   |                 |                    | to how bot input's fed into clients.                          |
   | SV_ClientThink  | server/sv_client.c | Seems to take input commands and simulate a client.           |
   | ClientThink     | game/g_client.c    | Actually runs the 'pmove' set of commands (after a validation |
   |                 |                    | check, passing ctrl to ClientThink_real)                      |
   
** VM_Call Mappings

   | Enum                | File             | Actual Routine Called |
   |---------------------+------------------+-----------------------|
   | BOTAI_START_FRAME   | game/g_main.c    | BotAIStartFrame       |
   | BOTLIB_USER_COMMAND | server/sv_game.c | SV_ClientThink        |
   | GAME_CLIENT_THINK   | game/g_main.c    | ClientThink           |
   | GAME_CLIENT_COMMAND | game/g_main.c    | ClientCommand         | 

** Key Data Structures
   | Name          | Location   | Purpose                           |
   |---------------+------------+-----------------------------------|
   | playerState_t | q_shared.h | State of each player, as received |
   |               |            | over network                      |
   | entityState_t | q_shared.h | State of any entity, as received  |
   |               |            | over network.  playerState_t is a |
   |               |            | proper superset.                  |
** Renderer
   - Looks like the renderer is pluggable.  RE_RenderScene and
     trap_R_RenderScene().
   - 'tr' in tr_main.c seems to maintain the draw graph.  NO, it's the
     vtable. 
   - "RE" is the "refresh" module.  tr_public.h:30
* Networking
  see cg_snapshot.c
  - Note: L245 in cg_snapshot.c: CG_BuildSolidList().  Does this thing
    store them only as renderables client-side?.  There has to be some
    simulation going on.  Nah, just maintains a count of solid vs
    "trigger" entities.

** Client-Side Networking
   - cl_main.c:CL_PacketEvent
   - cl_parse.c:CL_ParseServerMessage
   - cl_parse.c:CL_ParseSnapshot
   - 
* Simulation
** AI link-in to sv-main.
   - Maybe the easiest way is to just have my own routine feed in?
   - Some sort of configuration management is needed here.
     - Console variables! -- NO.  They have various
       archive/replication policies which could really mess things up.
     - Added new api under ls_variables.h
       | Variable     | Purpose                  | To-enable      |
       |--------------+--------------------------+----------------|
       | lsp_simulate | Run load simulator       | lsp_simulate=1 |
       | lsp_headless | Disable graphics display | lsp_headless=1 |

     - [X] Setup a new file, header, and set of flag facilities.


   - Can I just get SV_ClientThink called on the actual player's
     commands?
     - There are flag-checks in ClientThink (invoked via trap to
       GAME_CLIENT_THINK). Make sure to take those out/reroute/etc. 
   - SV_Main (conditional for simulation) invokes a botlib command
     that generates commands for client nr 0 (the actual one).  Looks
     like right now, it's 1+.
     - Umm, SV_Main() is server side.  Client 0 isn't special, it's
       just the human in the game, and there's always at least one (to
       start the game!).  Server-side botlib commands can be studied,
       but should probably stay in as normal.

*** clientActive_t (client.h) has mouseDx/mouseDy members,	      :WRONG:
    which may be sent directly over to the other side.  This may be a
    decent place for a port of the simulator.
    - Actually it's all taken care of in CL_ClientCmd, et al.

** Current Bot path (incl networking)
   - They are created, from the looks of it, to fill a room that has
     too few other players.  Looks like from G_BotConnect
   - G_BotConnect (game/g_bot.c:538) is called from ClientConnect
     (g_client.c:~915), the primary routine invoked upon client
     login. 

   - Looks like ClientConnect could be called with a flag saying "I'm
     a bot".  Invoked from vm(GAME_CLIENT_CONNECT).  3 Callers to
     that VM:
     - _sv_init.c:538_
       Change server to new map - SV_SpawnServer - takes all clients
       with it. 
       
     - _sv_ccmds.c:319_
       Map restart. SV_MapRestart_f

     - _sv_client.c:526_
       SV_DirectConnect - looks like the initial connection (server
       side). Question is, how's this work client-side?  Can I just
       rewire that bit and make it look like a real player to the
       normal world?

*** Current Login Path
    - Must find primary login path for a normal client.
    - Then figure out where to get botlib running instead. 

    - (cl_main.c) CL_Connect_f() sets up a connection state, which is then picked
      up by CL_CheckForResend
    
    - Primary packet input processing (client-side, at least) is
      CL_ParseServerMessage. 
    - Server-side packet input processing is SV_ExecuteClientMessage

    - SV_PacketEvent->SV_ExecuteClientMessage->SV_ClientCommand
      ->SV_ExecuteClientCommand

    - Before the "netchan" can be set up, a
      "connect/challenge/connectResponse" cycle is executed.
      - CL_ConnectionLessPacket
      - SV_DirectConnect

*** With current login path
    - How do I bind the client to botlib?
    - Likely, the bots are designed for use only on the server.
    - [ ] Instead, check out the line "CL_SendCmd()" in
	  cl_main.c/CL_Frame().
    - If that was a botlib call instead, we may have a reasonable
      simulator on our hands.
    
    - [ ] G_BotConnect (int clientnum, qboolean restart)
      - clientnum (set to 0 *should* work)
      - restart = false
       	- it's for looking up existing bot data that was saved. 
      
    - [ ] We can modify CL_SendCmd() to send in botlib commands instead
      (or added to) the local user.
    - [ ] How do bots sense their environment?

** Botlib Analysis
   - bot_entitystate_t is the internal state of a bot (origin,
     angles, type, flags, model, weapon).  Doesn't seem to contain any
     health points, etc.
     
   | VTable          | Purpose                      |
   |-----------------+------------------------------|
   | botlib_import_t | exported functions to botlib |
   | aas_export_t    | provided by aas_*.[ch]       |
   | ea_export_t     | exported by be_ea.c          |
   | ai_export_t     | exported by be_ai_*.[ch]     |

   - Acronyms (!!)
     - AAS - Area Awareness System
     - EA - Elementary Action

   - I maybe able to run an independent copy of botlib on the client
     side, with a few mods..  First, call GetBotLibAPI(), with my own
     set of 'import' functions (a vtable that's passed in).
     - YES, start with copying SV_BotInitBotLib(), and modifying it
       as needed to setup a client-side botlib instance.
     - NOTE: all the imports passed in by SV_BotInitBotLib() are
       server-side.  We'll have to construct client-side equivalents
       where they can't be directly ported over.
** Client Data Analysis
   - playerState_t holds damage 
   - Where are the client-side entities held?  Can I find a routine to
     scan an area for me?
     - Scan the renderer.
** Integration
*** Plan
    Overall, wire up a dumb "move-random" dummy client, then integrate
    botlib. 
    - [X] Modify CL_SendCmd.  It's easier.
    - [X] A command-line switch, lsp_simulate (already wired into
      argc/argv, but I need to check it) wired into LS_Enabled.  It
      should just flip s_enabled.  Read in at first-run of LS_Enabled
      now. 

*** BotImport 
**** DONE BotImport_Trace					    :LOADSIM:
     One of the key integration routines.  It links, most relevantly,
     to SV_Trace(), which goes to SV_Trace_r(), which then goes to
     scan sv_worldSectors[], a bsp tree of the world.
     - How do I go about scanning the client-side view of the world?
     - Find it in the *renderer*
       - No, that's too poly-based.  Let's try client snapshot reading
	 instead.  There's playerState_t, a superset of entityState_t.
       - Well, let's consider this in terms of the API SV_Trace()
	 actually needs.
	 - What does SV_Trace() use? -- it's maintaining an internal
	   BSP of all the entities in the world.  I won't be doing
	   that, but then again, it's to save server-side CPU.  I can
	   waste it on the client-side happily with little ill effect.

	 - What can I use instead of the server-side BSP?
	   - All I have is what the client receives.  I can scan that,
             I suppose.  
	 - Looking at the interface for BotImport_Trace(), the result
           is stored in a parameter: bsp_trace_t *bsptrace, which is a
           structure in botlib.h:

	   = typedef struct bsp_trace_s
	   = {
	   = 	qboolean		allsolid;	// if true, plane is not valid
	   = 	qboolean		startsolid;	// if true, the initial point was in a solid area
	   = 	float			fraction;	// time completed, 1.0 = didn't hit anything
	   = 	vec3_t			endpos;		// final position
	   = 	cplane_t		plane;		// surface normal at impact
	   = 	float			exp_dist;	// expanded plane distance
	   = 	int			sidenum;	// number of the brush side hit
	   = 	bsp_surface_t	        surface;	// the hit point surface
	   = 	int			contents;	// contents on other side of surface hit
	   = 	int			ent;		// number of entity hit
	   = } bsp_trace_t;
	   - Note the last element `ent`, which corresponds to an
             entityState_t. 

     - I could sort all entities across the vector, and scan that ways:
       nlogn * compare_time<entity>().
       - What's the current representational shape of an entity?  And
         that of the box being slid across the vector?
         | Type | Sliding Box | Entity |
         |------+-------------+--------|
         | AABB | YUP         |        |
         | OOBB |             |        |

   CM_Trace usage:
     Called as:
     | Arg             | Got? | Calculate |
     |-----------------+------+-----------|
     | &trace          |      |           |
     | start_l         |      |           |
     | end_l           |      |           |
     | symetricSize[0] |      |           |
     | symetricSize[1] |      |           |
     | model           |      |           |
     | origin          |      |           |
     | brushmask       |      |           |
     | capsule         |      |           |
     |                 |      |           |
     Called from CM_TransformedBoxTrace(
     | Arg                   | Got? | Calculate |
     |-----------------------+------+-----------|
     | &trace                |      |           |
     | (float *) clip->start |      |           |
     | (float *) clip->end   |      |           |
     | (float *) clip->mins  |      |           |
     | (float *) clip->maxs  |      |           |
     | clipHandle            |      |           |
     | clip->contentmask     |      |           |
     | origin                |      |           |
     | angles                |      |           |
     | clip->capsule         |      |           |
     )
     Called from SV_ClipMoveToEntities(moveclip_t)
     
     Called from SV_Trace
       | Arg           | Origin |
       |---------------+--------|
       | contentmask   | arg    |
       | start         | arg    |
       | end           | arg    |
       | mins          | arg    |
       | maxs          | arg    |
       | passEntityNum | arg    |
       | capsule       | qfalse |

**** Source Analysis
     
| SV_Trace  - sv_world.c:600                                            | Comment                  |
|-----------------------------------------------------------------------+--------------------------|
| > moveclip_t      clip;                                               |                          |
| > int                     i;                                          |                          |
| >                                                                     |                          |
| > if ( !mins ) {                                                      | defaults to origin       |
| >         mins = vec3_origin;                                         |                          |
| > }                                                                   |                          |
| > if ( !maxs ) {                                                      |                          |
| >         maxs = vec3_origin;                                         |                          |
| > }                                                                   |                          |
| >                                                                     |                          |
| > Com_Memset ( &clip, 0, sizeof ( moveclip_t ) );                     |                          |
| >                                                                     |                          |
| > // clip to world                                                    |                          |
| > CM_BoxTrace( &clip.trace, start, end, mins, maxs, \                 | call CM_BoxTrace         |
| >              0, contentmask, capsule );                             | Some sort of retcode     |
| > clip.trace.entityNum = clip.trace.fraction != 1.0 ? \               | analysis mapped to enums |
| >              ENTITYNUM_WORLD : ENTITYNUM_NONE;                      |                          |
| > if ( clip.trace.fraction == 0 ) {                                   |                          |
| >         *results = clip.trace;                                      |                          |
| >         return;         // blocked immediately by the world         |                          |
| > }                                                                   |                          |
| >                                                                     |                          |
| > clip.contentmask = contentmask;                                     |                          |
| > clip.start = start;                                                 |                          |
| >                                                                     |                          |
| > VectorCopy( end, clip.end );                                        |                          |
| > clip.mins = mins;                                                   |                          |
| > clip.maxs = maxs;                                                   |                          |
| > clip.passEntityNum = passEntityNum;                                 |                          |
| > clip.capsule = capsule;                                             |                          |
| >                                                                     |                          |
| > // create the bounding box of the entire move                       |                          |
| > // we can limit it to the part of the move not                      |                          |
| > // already clipped off by the world, which can be                   |                          |
| > // a significant savings for line of sight and shot traces          |                          |
| > for ( i=0 ; i<3 ; i++ ) {                                           | build bounding box       |
| >         if ( end[i] > start[i] ) {                                  |                          |
| >                 clip.boxmins[i] = clip.start[i] + clip.mins[i] - 1; |                          |
| >                 clip.boxmaxs[i] = clip.end[i] + clip.maxs[i] + 1;   |                          |
| >         } else {                                                    |                          |
| >                 clip.boxmins[i] = clip.end[i] + clip.mins[i] - 1;   |                          |
| >                 clip.boxmaxs[i] = clip.start[i] + clip.maxs[i] + 1; |                          |
| >         }                                                           |                          |
| > }                                                                   |                          |
| >                                                                     |                          |
| > // clip to other solid entities                                     |                          |
| > SV_ClipMoveToEntities ( &clip );                                    | SV_ClipMoveToEntities    |
| >                                                                     |                          |
| > *results = clip.trace;                                              |                          |
| >                                                                     |                          |
|-----------------------------------------------------------------------+--------------------------|

| CM_BoxTrace - calls CM_Trace |

| CM_Trace - cm_trace.c:1142                                                                              | Comment                     |
|---------------------------------------------------------------------------------------------------------+-----------------------------|
| > int                     i;                                                                            |                             |
| > traceWork_t     tw;                                                                                   |                             |
| > vec3_t          offset;                                                                               |                             |
| > cmodel_t        *cmod;                                                                                |                             |
| >                                                                                                       |                             |
| > cmod = CM_ClipHandleToModel( model );                                                                 | What's a handle?            |
| >                                                                                                       |                             |
| > cm.checkcount++;                // for multi-check avoidance                                          |                             |
| >                                                                                                       |                             |
| > c_traces++;                             // for statistics, may be zeroed                              |                             |
| >                                                                                                       |                             |
| > // fill in a default trace                                                                            |                             |
| > Com_Memset( &tw, 0, sizeof(tw) );                                                                     |                             |
| > tw.trace.fraction = 1;  // assume it goes the entire distance until shown otherwise                   |                             |
| > VectorCopy(origin, tw.modelOrigin);                                                                   |                             |
| >                                                                                                       |                             |
| > if (!cm.numNodes) {                                                                                   |                             |
| >         *results = tw.trace;                                                                          |                             |
| >                                                                                                       |                             |
| >         return; // map not loaded, shouldn't happen                                                   |                             |
| > }                                                                                                     |                             |
| >                                                                                                       |                             |
| > // allow NULL to be passed in for 0,0,0                                                               |                             |
| > if ( !mins ) {                                                                                        |                             |
| >         mins = vec3_origin;                                                                           |                             |
| > }                                                                                                     |                             |
| > if ( !maxs ) {                                                                                        |                             |
| >         maxs = vec3_origin;                                                                           |                             |
| > }                                                                                                     |                             |
| >                                                                                                       |                             |
| > // set basic parms                                                                                    |                             |
| > tw.contents = brushmask;                                                                              |                             |
| >                                                                                                       |                             |
| > // adjust so that mins and maxs are always symetric, which                                            |                             |
| > // avoids some complications with plane expanding of rotated                                          |                             |
| > // bmodels                                                                                            |                             |
| > for ( i = 0 ; i < 3 ; i++ ) {                                                                         |                             |
| >         offset[i] = ( mins[i] + maxs[i] ) * 0.5;                                                      |                             |
| >         tw.size[0][i] = mins[i] - offset[i];                                                          |                             |
| >         tw.size[1][i] = maxs[i] - offset[i];                                                          |                             |
| >         tw.start[i] = start[i] + offset[i];                                                           |                             |
| >         tw.end[i] = end[i] + offset[i];                                                               |                             |
| > }                                                                                                     |                             |
| >                                                                                                       |                             |
| > // if a sphere is already specified                                                                   |                             |
| > if ( sphere ) {                                                                                       |                             |
| >         tw.sphere = *sphere;                                                                          |                             |
| > }                                                                                                     |                             |
| > else {                                                                                                |                             |
| >         tw.sphere.use = capsule;                                                                      |                             |
| >         tw.sphere.radius = ( tw.size[1][0] > tw.size[1][2] ) ? tw.size[1][2]: tw.size[1][0];          |                             |
| >         tw.sphere.halfheight = tw.size[1][2];                                                         |                             |
| >         VectorSet( tw.sphere.offset, 0, 0, tw.size[1][2] - tw.sphere.radius );                        |                             |
| > }                                                                                                     |                             |
| >                                                                                                       |                             |
| > tw.maxOffset = tw.size[1][0] + tw.size[1][1] + tw.size[1][2];                                         |                             |
| >                                                                                                       |                             |
| > // tw.offsets[signbits] = vector to apropriate corner from origin                                     |                             |
| > tw.offsets[0][0] = tw.size[0][0];                                                                     |                             |
| > tw.offsets[0][1] = tw.size[0][1];                                                                     |                             |
| > tw.offsets[0][2] = tw.size[0][2];                                                                     |                             |
| >                                                                                                       |                             |
| > tw.offsets[1][0] = tw.size[1][0];                                                                     |                             |
| > tw.offsets[1][1] = tw.size[0][1];                                                                     |                             |
| > tw.offsets[1][2] = tw.size[0][2];                                                                     |                             |
| >                                                                                                       |                             |
| > tw.offsets[2][0] = tw.size[0][0];                                                                     |                             |
| > tw.offsets[2][1] = tw.size[1][1];                                                                     |                             |
| > tw.offsets[2][2] = tw.size[0][2];                                                                     |                             |
| >                                                                                                       |                             |
| > tw.offsets[3][0] = tw.size[1][0];                                                                     |                             |
| > tw.offsets[3][1] = tw.size[1][1];                                                                     |                             |
| > tw.offsets[3][2] = tw.size[0][2];                                                                     |                             |
| >                                                                                                       |                             |
| > tw.offsets[4][0] = tw.size[0][0];                                                                     |                             |
| > tw.offsets[4][1] = tw.size[0][1];                                                                     |                             |
| > tw.offsets[4][2] = tw.size[1][2];                                                                     |                             |
| >                                                                                                       |                             |
| > tw.offsets[5][0] = tw.size[1][0];                                                                     |                             |
| > tw.offsets[5][1] = tw.size[0][1];                                                                     |                             |
| > tw.offsets[5][2] = tw.size[1][2];                                                                     |                             |
| >                                                                                                       |                             |
| > tw.offsets[6][0] = tw.size[0][0];                                                                     |                             |
| > tw.offsets[6][1] = tw.size[1][1];                                                                     |                             |
| > tw.offsets[6][2] = tw.size[1][2];                                                                     |                             |
| >                                                                                                       |                             |
| > tw.offsets[7][0] = tw.size[1][0];                                                                     |                             |
| > tw.offsets[7][1] = tw.size[1][1];                                                                     |                             |
| > tw.offsets[7][2] = tw.size[1][2];                                                                     |                             |
| >                                                                                                       |                             |
| > //                                                                                                    |                             |
| > // calculate bounds                                                                                   |                             |
| > //                                                                                                    |                             |
| > if ( tw.sphere.use ) {                                                                                |                             |
| >         for ( i = 0 ; i < 3 ; i++ ) {                                                                 |                             |
| >                 if ( tw.start[i] < tw.end[i] ) {                                                      |                             |
| >                         tw.bounds[0][i] = tw.start[i] - fabs(tw.sphere.offset[i]) - tw.sphere.radius; |                             |
| >                         tw.bounds[1][i] = tw.end[i] + fabs(tw.sphere.offset[i]) + tw.sphere.radius;   |                             |
| >                 } else {                                                                              |                             |
| >                         tw.bounds[0][i] = tw.end[i] - fabs(tw.sphere.offset[i]) - tw.sphere.radius;   |                             |
| >                         tw.bounds[1][i] = tw.start[i] + fabs(tw.sphere.offset[i]) + tw.sphere.radius; |                             |
| >                 }                                                                                     |                             |
| >         }                                                                                             |                             |
| > }                                                                                                     |                             |
| > else {                                                                                                |                             |
| >         for ( i = 0 ; i < 3 ; i++ ) {                                                                 |                             |
| >                 if ( tw.start[i] < tw.end[i] ) {                                                      |                             |
| >                         tw.bounds[0][i] = tw.start[i] + tw.size[0][i];                                |                             |
| >                         tw.bounds[1][i] = tw.end[i] + tw.size[1][i];                                  |                             |
| >                 } else {                                                                              |                             |
| >                         tw.bounds[0][i] = tw.end[i] + tw.size[0][i];                                  |                             |
| >                         tw.bounds[1][i] = tw.start[i] + tw.size[1][i];                                |                             |
| >                 }                                                                                     |                             |
| >         }                                                                                             |                             |
| > }                                                                                                     |                             |
| >                                                                                                       |                             |
| > //                                                                                                    |                             |
| > // check for position test special case                                                               |                             |
| > //                                                                                                    |                             |
| > if (start[0] == end[0] && start[1] == end[1] && start[2] == end[2]) {                                 |                             |
| >         if ( model ) {                                                                                |                             |
| > #ifdef ALWAYS_BBOX_VS_BBOX // FIXME - compile time flag?                                              |                             |
| >                 if ( model == BOX_MODEL_HANDLE \\ model == CAPSULE_MODEL_HANDLE) {                    |                             |
| >                         tw.sphere.use = qfalse;                                                       |                             |
| >                         CM_TestInLeaf( &tw, &cmod->leaf );                                            | CM_TestInLeaf               |
| >                 }                                                                                     |                             |
| >                 else                                                                                  |                             |
| > #elif defined(ALWAYS_CAPSULE_VS_CAPSULE)                                                              |                             |
| >                 if ( model == BOX_MODEL_HANDLE \\ model == CAPSULE_MODEL_HANDLE) {                    |                             |
| >                         CM_TestCapsuleInCapsule( &tw, model );                                        | CM_TestCapsuleInCapsule     |
| >                 }                                                                                     |                             |
| >                 else                                                                                  |                             |
| > #endif                                                                                                |                             |
| >                 if ( model == CAPSULE_MODEL_HANDLE ) {                                                |                             |
| >                         if ( tw.sphere.use ) {                                                        |                             |
| >                                 CM_TestCapsuleInCapsule( &tw, model );                                | CM_TestCapsuleInCapsule     |
| >                         }                                                                             |                             |
| >                         else {                                                                        |                             |
| >                                 CM_TestBoundingBoxInCapsule( &tw, model );                            | CM_TestBoundingBoxInCapsule |
| >                         }                                                                             |                             |
| >                 }                                                                                     |                             |
| >                 else {                                                                                |                             |
| >                         CM_TestInLeaf( &tw, &cmod->leaf );                                            |                             |
| >                 }                                                                                     |                             |
| >         } else {                                                                                      |                             |
| >                 CM_PositionTest( &tw );                                                               | CM_PositionTest             |
| >         }                                                                                             |                             |
| > } else {                                                                                              |                             |
| >         //                                                                                            |                             |
| >         // check for point special case                                                               |                             |
| >         //                                                                                            |                             |
| >         if ( tw.size[0][0] == 0 && tw.size[0][1] == 0 && tw.size[0][2] == 0 ) {                       |                             |
| >                 tw.isPoint = qtrue;                                                                   |                             |
| >                 VectorClear( tw.extents );                                                            |                             |
| >         } else {                                                                                      |                             |
| >                 tw.isPoint = qfalse;                                                                  |                             |
| >                 tw.extents[0] = tw.size[1][0];                                                        |                             |
| >                 tw.extents[1] = tw.size[1][1];                                                        |                             |
| >                 tw.extents[2] = tw.size[1][2];                                                        |                             |
| >         }                                                                                             |                             |
| >                                                                                                       |                             |
| >         //                                                                                            |                             |
| >         // general sweeping through world                                                             |                             |
| >         //                                                                                            |                             |
| >         if ( model ) {                                                                                |                             |
| > #ifdef ALWAYS_BBOX_VS_BBOX                                                                            |                             |
| >                 if ( model == BOX_MODEL_HANDLE \\ model == CAPSULE_MODEL_HANDLE) {                    |                             |
| >                         tw.sphere.use = qfalse;                                                       |                             |
| >                         CM_TraceThroughLeaf( &tw, &cmod->leaf );                                      |                             |
| >                 }                                                                                     |                             |
| >                 else                                                                                  |                             |
| > #elif defined(ALWAYS_CAPSULE_VS_CAPSULE)                                                              |                             |
| >                 if ( model == BOX_MODEL_HANDLE \\ model == CAPSULE_MODEL_HANDLE) {                    |                             |
| >                         CM_TraceCapsuleThroughCapsule( &tw, model );                                  |                             |
| >                 }                                                                                     |                             |
| >                 else                                                                                  |                             |
| > #endif                                                                                                |                             |
| >                 if ( model == CAPSULE_MODEL_HANDLE ) {                                                |                             |
| >                         if ( tw.sphere.use ) {                                                        |                             |
| >                                 CM_TraceCapsuleThroughCapsule( &tw, model );                          |                             |
| >                         }                                                                             |                             |
| >                         else {                                                                        |                             |
| >                                 CM_TraceBoundingBoxThroughCapsule( &tw, model );                      |                             |
| >                         }                                                                             |                             |
| >                 }                                                                                     |                             |
| >                 else {                                                                                |                             |
| >                         CM_TraceThroughLeaf( &tw, &cmod->leaf );                                      |                             |
| >                 }                                                                                     |                             |
| >         } else {                                                                                      |                             |
| >                 CM_TraceThroughTree( &tw, 0, 0, 1, tw.start, tw.end );                                |                             |
| >         }                                                                                             |                             |
| > }                                                                                                     |                             |
| >                                                                                                       |                             |
| > // generate endpos from the original, unmodified start/end                                            |                             |
| > if ( tw.trace.fraction == 1 ) {                                                                       |                             |
| >         VectorCopy (end, tw.trace.endpos);                                                            |                             |
| > } else {                                                                                              |                             |
| >         for ( i=0 ; i<3 ; i++ ) {                                                                     |                             |
| >                 tw.trace.endpos[i] = start[i] + tw.trace.fraction * (end[i] - start[i]);              |                             |
| >         }                                                                                             |                             |
| > }                                                                                                     |                             |
| >                                                                                                       |                             |
| > // If allsolid is set (was entirely inside something solid), the plane is not valid.                  |                             |
| > // If fraction == 1.0, we never hit anything, and thus the plane is not valid.                        |                             |
| > // Otherwise, the normal on the plane should have unit length                                         |                             |
| > assert(tw.trace.allsolid \\                                                                           |                             |
| >        tw.trace.fraction == 1.0 \\                                                                    |                             |
| >        VectorLengthSquared(tw.trace.plane.normal) > 0.9999);                                          |                             |
| > *results = tw.trace;                                                                                  |                             |

**** DONE BotImport_EntityTrace					    :LOADSIM:
     "trace a bbox against a specific entity"
     - Just a wrapper around SV_ClipToEntity

**** SV_ClipToEntity
     Calls SV_GentityNum
     - Just returns an address to a sharedEntity_t. A one-liner
       address-of from an array.
     Calls SV_ClipHandleForEntity
     - two if()s and a final branch.  Each calling one of
     [CM_InlineModel, CM_TempBoxModel]
     Calls CM_TransformedBoxTrace

**** DONE BotImport_PointContents				    :LOADSIM:
     Calls SV_PointContents(point, -1)
     
**** DONE BotImport_inPVS					    :LOADSIM:
     Calls SV_inPVS(p1,p2)

*** Movements
    Surprisingly easy.  Just shove a usercmd_t into the client state,
    and it'll get shoved across when it's time.

* Headless Operation
  A priority, as Xepher's unhappy with DISPLAY=:2.0
  Initial questions
** Where's the X window setup?
   - At least some part is in R_Init() in renderer/tr_init.c
   - Additionally, it looks like it's hooked in via
     RE_BeginRegistration(), which is an implementation of a vtable
     setup by GetRefAPI().  GetRefAPI()'s getting called from:

** Where's the rendering?
   - Uses for glVertex:
     | File         | Use                                  |
     |--------------+--------------------------------------|
     | tr_surface.c | RB_SurfaceBeam, RB_SurfaceAxis       |
     | tr_init.c    | glxInfo_f                            |
     | tr_backend.c | RE_StretchRaw, RB_ShowImages         |
     | tr_shadows.c | R_RenderShadowEdges, RB_ShadowFinish |
     | tr_sky.c     |                                      |
     | tr_shade.c   |                                      |
     | tr_main.c    |                                      |
   - Skip it.  It's all in the callbacks coming from tr_init.
   - All calls to it are via the GetRefAPI() wrapper.  It's called
     from cl_main.c:2879.  I can easily make that point somewhere
     else.  Then it's a matter of stubbing out the APIs.

    | API                     | E. Diff. | Status | Notes               |
    |-------------------------+----------+--------+---------------------|
    | Shutdown                | -        |        |                     |
    | BeginRegistration       |          |        |                     |
    | RegisterModel           | ?        |        | Returns a qhandle_t |
    | RegisterSkin            | ?        |        | "                   |
    | RegisterShader          | ?        |        | "                   |
    | RegisterShaderNoMip     | ?        |        | "                   |
    | LoadWorld               | -        |        |                     |
    | SetWorldVisData         | -        |        |                     |
    | EndRegistration         |          |        |                     |
    | ClearScene              |          |        |                     |
    | AddRefEntityToScene     |          |        |                     |
    | AddPolyToScene          |          |        |                     |
    | LightForPoint           |          |        |                     |
    | AddLightToScene         |          |        |                     |
    | AddAdditiveLightToScene |          |        |                     |
    | RenderScene             |          |        |                     |
    | SetColor                |          |        |                     |
    | DrawStretchPic          |          |        |                     |
    | DrawStretchRaw          |          |        |                     |
    | UploadCinematic         |          |        |                     |
    | BeginFrame              |          |        |                     |
    | EndFrame                |          |        |                     |
    | MarkFragments           |          |        |                     |
    | LerpTag                 |          |        |                     |
    | ModelBounds             |          |        |                     |
    | RegisterFont            |          |        |                     |
    | RemapShader             |          |        |                     |
    | GetEntityToken          |          |        |                     |
    | inPVS                   |          |        |                     |
    | TakeVideoFrame          |          |        |                     | 

     Note that I could just copy the entire subsystem and stub-out 99%
     of the code.
** Getting it done
   Bug 1: r_fullscreen isn't setup.  I need to setup some console
   variables, it seems.
   Holy shit, the fucker's working.  I forgot sound.
   
* Random Scalability Notes
  - g_public.h:64 - Max clients must be <= 32 for 'singleClient'
