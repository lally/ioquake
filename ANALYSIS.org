* Runtime Notes
  - SDL will _FAIL_ unless you unset LANG.
  - You can run this in *Xephyr*!!
    pfexec Xephyr :1.0 &
    xauth extract - $DISPLAY | DISPLAY=:1.0 xauth merge -
    DISPLAY=:1.0 ./ioquake3.i386

  - This works  *RELIABLY*
    - You may have to run ioquake a few times to make it go all the
      way through.
    - See build/run.sh !

* Source Code Notes
** Key Routines
   
   | Name            | Location           | Purpose                                                       |
   |-----------------+--------------------+---------------------------------------------------------------|
   | main            | sys/sys_main.c     | main() of program, both client and server.                    |
   | SV_Frame        | server/sv_main.c   | Primary simulation loop                                       |
   | SV_BotFrame     | server/sv_bot.c    | Invoke Bot AI                                                 |
   | BotAIStartFrame | game/g_main.c      | Invokes (vm) call to SV_ClientThink, after maintaining        |
   |                 |                    | internal bot-related data structures.  Seems relevant         |
   |                 |                    | to how bot input's fed into clients.                          |
   | SV_ClientThink  | server/sv_client.c | Seems to take input commands and simulate a client.           |
   | ClientThink     | game/g_client.c    | Actually runs the 'pmove' set of commands (after a validation |
   |                 |                    | check, passing ctrl to ClientThink_real)                      |
   
** VM_Call Mappings

   | Enum                | File             | Actual Routine Called |
   |---------------------+------------------+-----------------------|
   | BOTAI_START_FRAME   | game/g_main.c    | BotAIStartFrame       |
   | BOTLIB_USER_COMMAND | server/sv_game.c | SV_ClientThink        |
   | GAME_CLIENT_THINK   | game/g_main.c    | ClientThink           |
   | GAME_CLIENT_COMMAND | game/g_main.c    | ClientCommand         | 
  
* Simulation
** AI link-in to sv-main.
   - Maybe the easiest way is to just have my own routine feed in?
   - Some sort of configuration management is needed here.
     - Console variables! -- NO.  They have various
       archive/replication policies which could really mess things up.
     - Added new api under ls_variables.h
       | Variable     | Purpose                  | To-enable      |
       |--------------+--------------------------+----------------|
       | lsp_simulate | Run load simulator       | lsp_simulate=1 |
       | lsp_headless | Disable graphics display | lsp_headless=1 |

     - [X] Setup a new file, header, and set of flag facilities.


   - Can I just get SV_ClientThink called on the actual player's
     commands?
     - There are flag-checks in ClientThink (invoked via trap to
       GAME_CLIENT_THINK). Make sure to take those out/reroute/etc. 
   - SV_Main (conditional for simulation) invokes a botlib command
     that generates commands for client nr 0 (the actual one).  Looks
     like right now, it's 1+.

*** Current Bot path
    - They are created, from the looks of it, to fill a room that has
      too few other players.  Looks like from G_BotConnect
    - G_BotConnect (game/g_bot.c:538) is called from ClientConnect
      (g_client.c:~915), the primary routine invoked upon client
      login. 

    - Looks like ClientConnect could be called with a flag saying "I'm
      a bot".  Invoked from vm(GAME_CLIENT_CONNECT).  3 Callers to
      that VM:
      - _sv_init.c:538_
	Change server to new map - SV_SpawnServer - takes all clients
        with it. 
	
      - _sv_ccmds.c:319_
	Map restart. SV_MapRestart_f

      - _sv_client.c:526_
	SV_DirectConnect - looks like the initial connection (server
        side). Question is, how's this work client-side?  Can I just
        rewire that bit and make it look like a real player to the
        normal world?

*** Current Login Path
    - Must find primary login path for a normal client.
    - Then figure out where to get botlib running instead. 

    - (cl_main.c) CL_Connect_f() sets up a connection state, which is then picked
      up by CL_CheckForResend
    
    - Primary packet input processing (client-side, at least) is
      CL_ParseServerMessage. 
    - Server-side packet input processing is SV_ExecuteClientMessage

    - SV_PacketEvent->SV_ExecuteClientMessage->SV_ClientCommand
      ->SV_ExecuteClientCommand

    - Before the "netchan" can be set up, a
      "connect/challenge/connectResponse" cycle is executed.
      - CL_ConnectionLessPacket
      - SV_DirectConnect

*** With current login path
    - How do I bind the client to botlib?
    - Likely, the bots are designed for use only on the server.
    - Instead, check out the line "CL_SendCmd()" in
      cl_main.c/CL_Frame().
    - If that was a botlib call instead, we may have a reasonable
      simulator on our hands.
    
    - G_BotConnect (int clientnum, qboolean restart)
      - clientnum (set to 0 *should* work)
      - restart = false
	- it's for looking up existing bot data that was saved. 
      
    - We can modify CL_SendCmd() to send in botlib commands instead
      (or added to) the local user.
    - How do bots sense their environment?

*** Botlib Analysis
    - bot_entitystate_t is the internal state of a bot (origin,
      angles, type, flags, model, weapon).  Doesn't seem to contain any
      health points, etc.
      
    | VTable          | Purpose                      |
    |-----------------+------------------------------|
    | botlib_import_t | exported functions to botlib |
    | aas_export_t    | provided by aas_*.[ch]       |
    | ea_export_t     | exported by be_ea.c          |
    | ai_export_t     | exported by be_ai_*.[ch]     |

    - Acronyms (!!)
      - AAS - Area Awareness System
      - EA - Elementary Action

    - I maybe able to run an independent copy of botlib on the client
      side, with a few mods..  First, call GetBotLibAPI(), with my own
      set of 'import' functions (a vtable that's passed in).
      - YES, start with copying SV_BotInitBotLib(), and modifying it
        as needed to setup a client-side botlib instance.
      - NOTE: all the imports passed in by SV_BotInitBotLib() are
        server-side.  We'll have to construct client-side equivalents
        where they can't be directly ported over.
*** Client Data Analysis
    - playerState_t holds damage
*** Integration     
**** TODO BotImport_Trace					    :LOADSIM:
     One of the key integration routines.  It links, most relevantly,
     to SV_Trace(), which goes to SV_Trace_r(), which then goes to
     scan sv_worldSectors[], a bsp tree of the world.
     - How do I go about scanning the client-side view of the world?
     - Find it in the *renderer*
       - No, that's too poly-based.  Let's try client snapshot reading
         instead.  There's playerState_t, a superset of entityState_t.
       - Well, let's consider this in terms of the API SV_Trace()
         actually needs.
         - What does SV_Trace() use? -- it's maintaining an internal
           BSP of all the entities in the world.  I won't be doing
           that, but then again, it's to save server-side CPU.  I can
           waste it on the client-side happily with little ill effect.

